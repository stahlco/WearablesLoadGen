package generator

import (
	"errors"
	"fmt"
	"hash/fnv"
	"math/rand"
	"time"

	"github.com/goccy/go-yaml"
)

type Config struct {
	MeasurementTypes map[string]MeasurementBlueprint `yaml:"measurement-types"`
}

type Payload struct {
	Type          string `json:"type"`
	SourceName    string `json:"sourceName"`
	SourceVersion string `json:"sourceVersion"`
	Unit          string `json:"unit"`
	// Those are variable and get generated by the generator
	Timestamp string `json:"endDate"`
	Value     string `json:"value"`
	DeviceID  string `json:"device"`
}

type MeasurementBlueprint struct {
	Type          string  `yaml:"type,omitempty"`
	SourceName    string  `yaml:"source-name,omitempty"`
	SourceVersion string  `yaml:"source-version,omitempty"`
	Min           float64 `yaml:"min,omitempty"`
	Max           float64 `yaml:"max,omitempty"`
	Unit          string  `yaml:"unit,omitempty"`
}

func ParseYAML(data []byte) (*Config, error) {
	var config Config

	if err := yaml.UnmarshalWithOptions(data, &config, yaml.Strict()); err != nil {
		return nil, err
	}
	if err := validateConfig(&config); err != nil {
		return nil, err
	}

	return &config, nil
}

func validateConfig(cfg *Config) error {
	if len(cfg.MeasurementTypes) == 0 {
		return errors.New("no measurement types in configuration")
	}

	for name, m := range cfg.MeasurementTypes {
		if m.Type == "" {
			return fmt.Errorf("measurement '%s' is missing 'type'", name)
		}
		if m.SourceName == "" {
			return fmt.Errorf("measurement '%s' is missing 'source-name'", name)
		}
		if m.SourceVersion == "" {
			return fmt.Errorf("measurement '%s' is missing 'source-version'", name)
		}
		if m.Unit == "" {
			return fmt.Errorf("measurement '%s' is missing 'unit'", name)
		}
		if m.Min >= m.Max {
			return fmt.Errorf("measurement '%s' has invalid range: min (%f) >= max (%f)", name, m.Min, m.Max)
		}
	}

	return nil
}

// GenerateMockPayload generates a payload with a correlated value for every device, based on hashing.
// It used the current time [time.DateTime] as the encoding.
func GenerateMockPayload(measurementType *MeasurementBlueprint, deviceID string) (*Payload, error) {
	if measurementType == nil {
		return nil, fmt.Errorf("measurementType is nil")
	}

	// Hash the device to a number between 0 and 1 -> Get correlated values for devices (to have normal patterns)
	hash := fnv.New32a()
	hash.Write([]byte(deviceID))
	deviceFactor := float64(hash.Sum32()%10000) / 10000.0

	avgValue := measurementType.Min + deviceFactor*(measurementType.Max-measurementType.Min)

	jitter := (rand.Float64()*0.1 - 0.05) * (measurementType.Max - measurementType.Min)
	finalValue := int(avgValue + jitter)

	timestamp := time.Now().Format(time.DateTime)

	return &Payload{
		Type:          measurementType.Type,
		SourceName:    measurementType.SourceName,
		SourceVersion: measurementType.SourceVersion,
		Unit:          measurementType.Unit,
		Timestamp:     timestamp,
		Value:         fmt.Sprint(finalValue),
		DeviceID:      deviceID,
	}, nil
}
